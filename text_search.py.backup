    def _do_api_request(self):
        """在新线程中处理API请求"""
        try:
            current_text = self.text_input.get("1.0", "end").strip()
            
            # 检查API密钥是否为空
            if not self.GPT_API_KEY or self.GPT_API_KEY.strip() == "":
                if self.main_window:
                    self.main_window.after(0, self.show_message, "GPT API密钥未配置，请先在设置中输入API密钥")
                return
            
            # 检查输入文本是否为空
            if not current_text:
                if self.main_window:
                    self.main_window.after(0, self.show_message, "请输入要提问的问题")
                return
            
            data = {
                "model": "gpt-3.5-turbo",
                "messages": [
                    {
                        "role": "system",
                        "content": "你是一个用中文回答问题的AI助手"
                    },
                    {
                        "role": "user",
                        "content": current_text
                    }
                ],
                "temperature": 0.7
            }
            
            # 添加调试信息
            print(f"请求URL: {self.GPT_API_URL}")
            print(f"请求头: {{'Content-Type': 'application/json', 'Authorization': 'Bearer {self.GPT_API_KEY[:5]}...' if len(self.GPT_API_KEY) > 5 else 'Bearer [短密钥]'}}")
            print(f"请求数据: {data}")
            
            response = requests.post(
                self.GPT_API_URL,
                headers={
                    "Content-Type": "application/json",
                    "Authorization": f"Bearer {self.GPT_API_KEY}"
                },
                json=data,
                timeout=30
            )
            
            print(f"响应状态码: {response.status_code}")
            print(f"响应内容: {response.text[:500]}...")  # 只打印前500个字符
            
            if response.status_code == 200:
                try:
                    result = response.json()
                    if 'choices' in result and len(result['choices']) > 0:
                        answer = result['choices'][0]['message']['content']
                        if answer:
                            # 使用 after 在主线程中更新 UI
                            if self.main_window:
                                self.main_window.after(0, self._update_answer, answer)
                            return
                        else:
                            if self.main_window:
                                self.main_window.after(0, self.show_message, f"API返回内容为空: {response.text}")
                    else:
                        if self.main_window:
                            self.main_window.after(0, self.show_message, f"API响应格式错误，缺少choices字段: {response.text}")
                except json.JSONDecodeError as json_err:
                    if self.main_window:
                        self.main_window.after(0, self.show_message, f"响应JSON解析错误: {str(json_err)}\n响应内容: {response.text[:200]}...")
            else:
                # 尝试解析错误响应
                try:
                    error_result = response.json()
                    error_msg = error_result.get('error', {}).get('message', str(error_result))
                    if self.main_window:
                        self.main_window.after(0, self.show_message, f"API请求失败 (状态码: {response.status_code}): {error_msg}")
                except json.JSONDecodeError:
                    if self.main_window:
                        self.main_window.after(0, self.show_message, f"API请求失败 (状态码: {response.status_code}): {response.text[:200]}...")
            
        except requests.exceptions.Timeout:
            if self.main_window:
                self.main_window.after(0, self.show_message, "请求超时，请检查网络连接或API地址是否正确")
        except requests.exceptions.ConnectionError:
            if self.main_window:
                self.main_window.after(0, self.show_message, "网络连接错误，请检查网络连接和API地址")
        except Exception as e:
            if self.main_window:
                self.main_window.after(0, self.show_message, f"请求错误: {str(e)}")
        finally:
            # 使用 after 在主线程中恢复按钮状态
            if self.main_window:
                self.main_window.after(0, self._reset_buttons)